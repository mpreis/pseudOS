		     +--------------------------+
       	     |			CS 140			|
		     | PROJECT 2: USER PROGRAMS	|
		     | 	   DESIGN DOCUMENT     	|
		     +--------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Thomas Huetter <thomas.huetter@stud.sbg.ac.at>
Mario Preishuber <mario.preishuber@stud.sbg.ac.at>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

			   ARGUMENT PASSING
			   ================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> A2: Briefly describe how you implemented argument parsing.  How do
>> you arrange for the elements of argv[] to be in the right order?
>> How do you avoid overflowing the stack page?

---- RATIONALE ----

>> A3: Why does Pintos implement strtok_r() but not strtok()?

>> A4: In Pintos, the kernel separates commands into a executable name
>> and arguments.  In Unix-like systems, the shell does this
>> separation.  Identify at least two advantages of the Unix approach.

			     SYSTEM CALLS
			     ============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

Extensions of thread/threads.h:
	#define FD_INIT 2                    // The smallest possible value of a file-descriptor.
	#define FD_ARR_DEFAULT_LENGTH 128    // Default size of the file descriptors array.

Extensions of struct thread (threads/thread.h):
	struct file* fds[FD_ARR_DEFAULT_LENGTH];// This array holds pointers of all open files.
	struct list childs;						// List of children of this thread.
    struct child_process* child_info;		// Holds information of this thread.
    struct file* executable;				// Represents the executable which is executed by this thread.

Extensions of userprog/process.h:
	#define DEFAULT_EXIT_STATUS -1 	// The default exit status.

	struct child_process
	  {
	    struct list_elem childelem; // List element.
	    pid_t pid;                  // ID of the process.
	    int exit_status;            // Status which is passed to the system-call exit.
	    struct thread *parent;      // Reference to the process parent.
	    struct semaphore alive;     // This semaphore is down till the thread dies.
	    struct semaphore init;      // This semaphore goes up if the initialization is done.
	    bool load_success;          // Indicates if loading the executable was sucessful.
	    bool parent_is_waiting;     // Indicates if the parent is already waiting for this child.
	  };

>> B2: Describe how file descriptors are associated with open files.
>> Are file descriptors unique within the entire OS or just within a
>> single process?

Each thread holds an array, called fds, of struct file pointers. The 
file descriptor is computed by adding FD_INIT to the position of the 
file pointer in the fds array. We know that the file descriptors 0 and 1 
are reserved for the stdin and stdout. This is the reason why we add 
FD_INIT which has the value 2. 

To answer the question of above: File descriptor are unique within a
thread.

---- ALGORITHMS ----

>> B3: Describe your code for reading and writing user data from the
>> kernel.

>> B4: Suppose a system call causes a full page (4,096 bytes) of data
>> to be copied from user space into the kernel.  What is the least
>> and the greatest possible number of inspections of the page table
>> (e.g. calls to pagedir_get_page()) that might result?  What about
>> for a system call that only copies 2 bytes of data?  Is there room
>> for improvement in these numbers, and how much?

>> B5: Briefly describe your implementation of the "wait" system call
>> and how it interacts with process termination.

Each thread has a list of childs, which list element is of type
struct child_process. The first step is to lookup the given pid in
the list of childs. If the return value is NULL, there is no such
child and we return -1. The struct child_process holds a variable
parent_is_waiting which is TRUE if the parent called already wait
with this pid, is this the case we also return -1.

If there is a valid child and wait is called the first time for this 
pid we set parent_is_waiting to TRUE. Next we call sema_down on 
the alive variable of the child. If an new thread is created alive is
locked by the thread itself. Only if thread_exit is called this 
semaphore is released. In this case also the exit status is set.
A parent is on the waiters list of the alive semaphore till a child
calls thread_exit. After that the parent wakes up and is able to 
access the exit status of its child. Has the child already been 
terminated the parent is able to execute sema_down without waiting
and returns the exit status of the child. 

>> B6: Any access to user program memory at a user-specified address
>> can fail due to a bad pointer value.  Such accesses must cause the
>> process to be terminated.  System calls are fraught with such
>> accesses, e.g. a "write" system call requires reading the system
>> call number from the user stack, then each of the call's three
>> arguments, then an arbitrary amount of user memory, and any of
>> these can fail at any point.  This poses a design and
>> error-handling problem: how do you best avoid obscuring the primary
>> function of code in a morass of error-handling?  Furthermore, when
>> an error is detected, how do you ensure that all temporarily
>> allocated resources (locks, buffers, etc.) are freed?  In a few
>> paragraphs, describe the strategy or strategies you adopted for
>> managing these issues.  Give an example.

---- SYNCHRONIZATION ----

>> B7: The "exec" system call returns -1 if loading the new executable
>> fails, so it cannot return before the new executable has completed
>> loading.  How does your code ensure this?  How is the load
>> success/failure status passed back to the thread that calls "exec"?

>> B8: Consider parent process P with child process C.  How do you
>> ensure proper synchronization and avoid race conditions when P
>> calls wait(C) before C exits?  After C exits?  How do you ensure
>> that all resources are freed in each case?  How about when P
>> terminates without waiting, before C exits?  After C exits?  Are
>> there any special cases?

---- RATIONALE ----

>> B9: Why did you choose to implement access to user memory from the
>> kernel in the way that you did?

>> B10: What advantages or disadvantages can you see to your design
>> for file descriptors?

Disadvantages:
	* The maximum number of open files per thread is limited by FD_ARR_DEFAULT_LENGTH.
		Our implementation of open return -1 if this limit is reached.
	* Each thread holds an array of size FD_ARR_DEFAULT_LENGTH. This leads to a
		memory overhead if less than FD_ARR_DEFAULT_LENGTH files are opened.

Advantages:
	* Constant access time if we access a file, by calling:
		filesize, read, write, seek, tell, and close.
	* Linear access time if we access a file, by calling:
		open (because we have to lookup the next available fd)
	* There is no counter needed for the number of current open files. 

Improvements:
	* To reduce the memory overhead FD_ARR_DEFAULT_LENGTH should be small.
	* One solution for don't running out of file descriptors, because 
		FD_ARR_DEFAULT_LENGTH is to small is, e.g., to reallocate the array
		and double the size.

>> B11: The default tid_t to pid_t mapping is the identity mapping.
>> If you changed it, what advantages are there to your approach?

We did not change this mapping.

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?
